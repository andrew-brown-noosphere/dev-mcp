<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>We've Been Here Before: UDDI, Web Services, and the Agent Discovery Problem - DevExp.ai</title>
    <meta name="description" content="The agent discovery problem looks a lot like UDDI from 2002. Here's what that history tells us about what will and won't work.">

    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:wght@400;500;600;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">

    <style>
        :root {
            --color-primary: hsl(24, 90%, 52%);
            --color-accent: hsl(170, 85%, 42%);
            --color-background: #030712;
            --color-surface: rgba(255, 255, 255, 0.03);
            --color-border: rgba(255, 255, 255, 0.1);
            --color-text: #ffffff;
            --color-text-muted: rgba(255, 255, 255, 0.7);
            --color-text-subtle: rgba(255, 255, 255, 0.5);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Source Serif 4', Georgia, serif;
            background: var(--color-background);
            color: var(--color-text);
            line-height: 1.8;
            font-size: 18px;
        }

        .nav { border-bottom: 1px solid var(--color-border); padding: 20px 0; }
        .container { max-width: 700px; margin: 0 auto; padding: 0 24px; }
        .nav-inner { display: flex; justify-content: space-between; align-items: center; max-width: 700px; margin: 0 auto; padding: 0 24px; }
        .nav a { color: var(--color-text-muted); text-decoration: none; }
        .nav a:hover { color: var(--color-text); }
        .nav-brand { color: var(--color-primary); font-weight: 700; font-size: 1.25rem; }
        .nav-links { display: flex; gap: 24px; font-size: 0.9rem; }

        header { padding: 80px 0 40px; }
        .meta { color: var(--color-text-subtle); font-size: 0.9rem; margin-bottom: 16px; }
        h1 { font-size: 2.5rem; font-weight: 600; line-height: 1.2; margin-bottom: 24px; }

        article { padding-bottom: 80px; }
        h2 { font-size: 1.5rem; font-weight: 600; margin: 48px 0 24px; color: var(--color-text); }
        p { margin-bottom: 24px; color: var(--color-text-muted); }
        ul, ol { margin-bottom: 24px; padding-left: 24px; color: var(--color-text-muted); }
        li { margin-bottom: 8px; }
        strong { color: var(--color-text); }
        hr { border: none; border-top: 1px solid var(--color-border); margin: 48px 0; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 24px 0;
            font-size: 0.95rem;
        }
        th, td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid var(--color-border);
            color: var(--color-text-muted);
        }
        th { color: var(--color-text); font-weight: 600; }

        code {
            font-family: 'JetBrains Mono', monospace;
            background: var(--color-surface);
            padding: 2px 6px;
            font-size: 0.85em;
            color: var(--color-accent);
        }

        .footer { border-top: 1px solid var(--color-border); padding: 40px 0; text-align: center; color: var(--color-text-subtle); font-size: 0.875rem; }
        .footer a { color: var(--color-text-muted); text-decoration: none; margin: 0 12px; }

        @media (max-width: 600px) {
            h1 { font-size: 1.75rem; }
            body { font-size: 16px; }
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="nav-inner">
            <a href="/" class="nav-brand">DevExp.ai</a>
            <div class="nav-links">
                <a href="/blog.html">Blog</a>
                <a href="/#demo">Contact</a>
            </div>
        </div>
    </nav>

    <header>
        <div class="container">
            <div class="meta">January 20, 2026</div>
            <h1>We've Been Here Before: UDDI, Web Services, and the Agent Discovery Problem</h1>
        </div>
    </header>

    <article>
        <div class="container">

<p>Everyone working on agent infrastructure should study the history of UDDI. We're solving the same problem they tried to solve in 2000, and we're about to make many of the same mistakes.</p>

<h2>The Problem Then</h2>

<p>In the late 1990s and early 2000s, enterprises were building web services. SOAP let you call remote procedures over HTTP. WSDL described what operations a service offered. But there was a missing piece: how do you discover services in the first place?</p>

<p>Enter UDDI — Universal Description, Discovery, and Integration. The idea was simple and compelling:</p>

<ol>
<li>Services register themselves in a universal directory</li>
<li>Clients query the directory to find services matching their needs</li>
<li>Clients retrieve WSDL, understand capabilities, and connect</li>
</ol>

<p>UDDI was going to be DNS for web services. IBM, Microsoft, and SAP backed it. It was a W3C standard. Enterprise architects drew beautiful diagrams showing how it would all work.</p>

<p>It failed completely.</p>

<h2>Why UDDI Failed</h2>

<p>The post-mortems are instructive:</p>

<p><strong>Nobody wanted a universal registry.</strong> The value proposition assumed companies would publish their internal services to a shared directory. But enterprises didn't want competitors discovering their service capabilities. And they didn't trust a centralized registry controlled by IBM/Microsoft.</p>

<p><strong>Point-to-point was good enough.</strong> In practice, if you needed to integrate with Salesforce, you went to Salesforce's developer docs, got their WSDL, and built your integration. You didn't need a universal directory to find Salesforce — you already knew you needed Salesforce.</p>

<p><strong>The metadata was too complex.</strong> UDDI entries required extensive structured metadata: business entities, business services, binding templates, tModels. By the time you'd filled out all the UDDI registration forms, you could have just written documentation.</p>

<p><strong>REST won.</strong> While the SOAP/WSDL/UDDI stack was being standardized, developers discovered that simple HTTP + JSON was good enough for most use cases. The entire elaborate web services stack got routed around.</p>

<h2>The Problem Now</h2>

<p>Replace "web service" with "agent endpoint" and the parallels are uncomfortable:</p>

<ul>
<li>How does an agent discover services matching its needs?</li>
<li>How does an agent understand what capabilities an endpoint offers?</li>
<li>How does an agent know it can trust an endpoint?</li>
</ul>

<p>We're proposing solutions that look a lot like the web services stack:</p>

<table>
<tr><th>2002</th><th>2026</th></tr>
<tr><td>WSDL (capability description)</td><td>llms.txt, agent.json, MCP manifests</td></tr>
<tr><td>UDDI (discovery registry)</td><td>??? (currently: search indexes)</td></tr>
<tr><td>SOAP (protocol)</td><td>MCP, function calling</td></tr>
<tr><td>WS-Security (trust)</td><td>??? (doesn't exist)</td></tr>
</table>

<p>The discovery layer is conspicuously missing. And just like in 2002, multiple parties are proposing incompatible solutions while the actual discovery mechanism (search indexes) is completely separate from the capability description mechanism (llms.txt, etc.).</p>

<h2>What Actually Worked</h2>

<p>After UDDI failed, web services didn't disappear. But the discovery model changed:</p>

<p><strong>Developer portals replaced registries.</strong> Instead of querying a universal directory, you went to Stripe's website, read their docs, and integrated. Human-readable documentation plus well-designed APIs beat machine-readable registries.</p>

<p><strong>API marketplaces emerged for aggregation.</strong> RapidAPI, Mashape, and others created curated directories. But they were more like app stores than UDDI — human-curated, with reviews and pricing, not universal machine-queryable registries.</p>

<p><strong>Standards settled on the simple stuff.</strong> REST/JSON won over SOAP/XML. OpenAPI (Swagger) won over WSDL because it was simpler and more practical. The elaborate type systems and formal verification of WS-* got ignored.</p>

<p><strong>Trust stayed bilateral.</strong> OAuth and API keys handled authentication. There was no universal web services trust layer — each integration established trust directly with the provider.</p>

<h2>The Agent Discovery Question</h2>

<p>So what does this mean for agent infrastructure?</p>

<p><strong>Will there be a universal agent registry?</strong> History says probably not. UDDI failed despite IBM and Microsoft pushing it. A universal AI agent registry would face the same problems: who controls it, who trusts it, why would providers register.</p>

<p><strong>Will search indexes remain the discovery layer?</strong> This is the UDDI-free world we actually got — Google as the de facto registry for web content. It's possible agents will just keep using search indexes forever, with no specialized agent discovery protocol.</p>

<p><strong>Will llms.txt matter?</strong> Maybe. OpenAPI/Swagger succeeded where WSDL failed because it was simpler and tool-friendly. If llms.txt stays simple and tools adopt it, it could work. But the history suggests that formal capability descriptions tend to lose to good documentation.</p>

<p><strong>Will MCP become the standard?</strong> Possibly. SOAP was complex; REST was simple and won. MCP is simpler than building custom integrations for each LLM, but it's not as simple as just having a good API and documentation. The winner will probably be whatever requires the least ceremony.</p>

<h2>Lessons for Agent Infrastructure</h2>

<p>If I were betting on what will work, based on the UDDI history:</p>

<p><strong>Don't build universal registries.</strong> They don't get adopted. Instead, expect aggregators and curated directories — more like Product Hunt for AI capabilities than DNS for agents.</p>

<p><strong>Keep capability descriptions simple.</strong> llms.txt is on the right track by being a simple markdown file. The moment it becomes a complex schema with required fields and formal validation, it'll go the way of UDDI tModels.</p>

<p><strong>Assume discovery will be search.</strong> Until there's a compelling alternative, agents will discover capabilities through search indexes. Build for that reality, not for a hypothetical agent registry.</p>

<p><strong>Trust will be graph-based, not centralized.</strong> There won't be a universal certificate authority for agents. But pure point-to-point trust (API keys, OAuth) doesn't scale either. The likely winner: trust graphs anchored to domains. A <code>trust.json</code> that declares "I trust these endpoints" and lets trust propagate through networks. Think PGP web-of-trust, but for agent endpoints. Some early work on this at <a href="https://noosphere.tech" style="color: var(--color-primary)">noosphere.tech</a>.</p>

<p><strong>Simple protocols win.</strong> MCP is good because it's relatively simple. If a simpler alternative emerges, it'll probably win. Don't over-engineer.</p>

<h2>The Interesting Question</h2>

<p>The UDDI failure doesn't mean agent discovery is unsolvable — it means the UDDI approach (universal registries, complex metadata, centralized trust) was wrong.</p>

<p>What might actually work:</p>

<p><strong>Federated discovery.</strong> Instead of one registry, multiple competing registries that agents can query. More like DNS with multiple root servers than UDDI with a single directory.</p>

<p><strong>Capability fingerprinting.</strong> Instead of formal descriptions, agents learn to recognize capabilities from behavior. "This endpoint responds to queries about weather" learned from interaction, not declared in metadata.</p>

<p><strong>Trust graphs.</strong> Domain-anchored trust declarations (<code>trust.json</code>) that let trust propagate through networks. If I trust Stripe, and Stripe's trust.json says they trust Plaid, my agent can infer a trust path. Webs of trust rather than certificate hierarchies.</p>

<p><strong>Search-native discovery.</strong> Instead of fighting search indexes, building on top of them. Structured data that search indexes understand, so agent discovery is just a specialized search query.</p>

<p>These approaches are messier than UDDI's clean architecture, but messier is often what works.</p>

<h2>Conclusion</h2>

<p>The agent infrastructure community should read the UDDI post-mortems before building the next universal registry. The problems are the same: discovery, capability description, trust. The failed solutions are the same: centralized registries, complex metadata, universal trust layers.</p>

<p>What worked for web services was simpler: good documentation, simple protocols, bilateral trust, and search-based discovery. The same will probably be true for agents.</p>

<p>The winners won't be the most architecturally elegant solutions. They'll be the ones that are simple enough to actually get adopted.</p>

<hr>

<p style="color: var(--color-text-subtle);">Further reading: "Whatever Happened to UDDI?" — various post-mortems from the mid-2000s. The WS-* specification graveyard. How OpenAPI succeeded where WSDL failed.</p>

        </div>
    </article>

    <footer class="footer">
        <div class="container">
            <a href="/">Home</a>
            <a href="/blog.html">Blog</a>
            <a href="/.well-known/agent.json">agent.json</a>
            <p style="margin-top: 24px;">© 2026 Voyant, LLC</p>
        </div>
    </footer>
</body>
</html>
