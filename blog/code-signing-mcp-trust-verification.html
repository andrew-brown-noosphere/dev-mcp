<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Why AI Agents Can't Just "Trust" Things - DevExp.ai</title>
    <meta name="description" content="SLSA, Sigstore, C2PA — the standards for verifiable software exist. But they were built for humans. AI agents need trust as a tool, not a gate.">

    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:wght@400;500;600;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">

    <style>
        :root {
            --color-primary: hsl(24, 90%, 52%);
            --color-accent: hsl(170, 85%, 42%);
            --color-background: #030712;
            --color-surface: rgba(255, 255, 255, 0.03);
            --color-border: rgba(255, 255, 255, 0.1);
            --color-text: #ffffff;
            --color-text-muted: rgba(255, 255, 255, 0.7);
            --color-text-subtle: rgba(255, 255, 255, 0.5);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Source Serif 4', Georgia, serif;
            background: var(--color-background);
            color: var(--color-text);
            line-height: 1.8;
            font-size: 18px;
        }

        .nav { border-bottom: 1px solid var(--color-border); padding: 20px 0; }
        .container { max-width: 700px; margin: 0 auto; padding: 0 24px; }
        .nav-inner { display: flex; justify-content: space-between; align-items: center; max-width: 700px; margin: 0 auto; padding: 0 24px; }
        .nav a { color: var(--color-text-muted); text-decoration: none; }
        .nav a:hover { color: var(--color-text); }
        .nav-brand { color: var(--color-primary); font-weight: 700; font-size: 1.25rem; }
        .nav-links { display: flex; gap: 24px; font-size: 0.9rem; }

        header { padding: 80px 0 40px; }
        .meta { color: var(--color-text-subtle); font-size: 0.9rem; margin-bottom: 16px; }

        h1 { font-size: 2.25rem; font-weight: 600; line-height: 1.2; margin-bottom: 24px; }

        article { padding-bottom: 80px; }
        h2 { font-size: 1.4rem; font-weight: 600; margin: 48px 0 24px; color: var(--color-text); }
        h3 { font-size: 1.15rem; font-weight: 600; margin: 32px 0 16px; color: var(--color-text); }
        p { margin-bottom: 24px; color: var(--color-text-muted); }
        .lead { font-size: 1.1rem; font-style: italic; color: var(--color-text-subtle); }

        ul, ol { margin-bottom: 24px; padding-left: 24px; color: var(--color-text-muted); }
        li { margin-bottom: 8px; }

        blockquote {
            margin: 32px 0;
            padding: 20px 24px;
            border-left: 3px solid var(--color-primary);
            background: var(--color-surface);
        }
        blockquote p { margin: 0; font-style: italic; }

        code {
            font-family: 'JetBrains Mono', monospace;
            background: var(--color-surface);
            padding: 2px 6px;
            font-size: 0.85em;
            color: var(--color-accent);
        }

        pre {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            padding: 20px;
            margin: 24px 0;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            color: var(--color-text-muted);
        }
        pre code { background: none; padding: 0; color: inherit; }

        strong { color: var(--color-text); }
        em { color: var(--color-text); }

        hr { border: none; border-top: 1px solid var(--color-border); margin: 48px 0; }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 24px 0;
            font-size: 0.95rem;
        }
        th, td {
            text-align: left;
            padding: 12px 16px;
            border-bottom: 1px solid var(--color-border);
        }
        th {
            color: var(--color-text);
            font-weight: 600;
            background: var(--color-surface);
        }
        td { color: var(--color-text-muted); }

        a { color: var(--color-primary); }
        a:hover { text-decoration: underline; }

        .about-section {
            border-top: 1px solid var(--color-border);
            padding: 48px 0;
            margin-top: 48px;
        }
        .about-section h3 {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--color-text);
        }
        .about-section p {
            font-size: 0.95rem;
            margin-bottom: 16px;
        }
        .cta-link {
            display: inline-block;
            color: var(--color-primary);
            font-weight: 500;
            text-decoration: none;
        }
        .cta-link:hover { text-decoration: underline; }

        .footer { border-top: 1px solid var(--color-border); padding: 40px 0; text-align: center; color: var(--color-text-subtle); font-size: 0.875rem; }
        .footer a { color: var(--color-text-muted); text-decoration: none; margin: 0 12px; }

        @media (max-width: 600px) {
            h1 { font-size: 1.75rem; }
            body { font-size: 16px; }
        }
    </style>
</head>
<body>
    <nav class="nav">
        <div class="nav-inner">
            <a href="/" class="nav-brand">DevExp.ai</a>
            <div class="nav-links">
                <a href="/blog.html">Blog</a>
                <a href="/#demo">Contact</a>
            </div>
        </div>
    </nav>

    <header>
        <div class="container">
            <div class="meta">February 9, 2026</div>
            <h1>Why AI Agents Can't Just "Trust" Things</h1>
        </div>
    </header>

    <article>
        <div class="container">

<p>A developer sees a suspicious npm package and pauses. Researches. Asks a colleague. An AI agent executing a build pipeline at 3am has no such luxury. It either has a programmatic way to verify trust, or it's flying blind.</p>

<p>The infrastructure for verifiable software exists. SLSA, Sigstore, in-toto, C2PA — serious standards, deployed in production, backed by Google, Linux Foundation, and major registries. npm has SLSA provenance. Container images carry attestations. The cryptographic primitives are real.</p>

<p>But they were all built for human workflows. A developer runs <code>cosign verify</code>. A CI system checks provenance. A security team reviews attestations. The verification happens, but it requires human orchestration.</p>

<p>AI agents need something different: <strong>trust as a tool they can invoke autonomously</strong>.</p>

<h2>The Gap</h2>

<p>When Claude is about to install a package, it can't pause and "feel suspicious." It can't ask a colleague. It can't Google the maintainer's reputation. It needs a tool call that returns a deterministic answer: trusted or not, with cryptographic evidence.</p>

<p>This is the gap: the standards exist, but agents can't access them.</p>

<p>SLSA tells you if a build is reproducible — but there's no <code>verify_slsa()</code> tool an agent can call. Sigstore provides keyless signing — but there's no MCP interface for querying the transparency log. C2PA embeds content credentials in media files — but agents can't extract and verify them mid-workflow.</p>

<p>The verification capabilities exist. The agent-accessible interfaces don't.</p>

<h2>What We Built</h2>

<p>We built <a href="https://github.com/anthropics/code-signing-mcp">code-signing-mcp</a> — an MCP server that exposes trust verification as tools AI agents can invoke:</p>

<ul>
    <li><code>sign_binary</code> — Sign any artifact with your choice of provider</li>
    <li><code>verify_signature</code> — Verify signatures and attestations</li>
    <li><code>verify_trust_chain</code> — Check if a signer is in your trust graph</li>
    <li><code>supply_chain_attestation</code> — Generate SLSA/in-toto attestations</li>
</ul>

<p>The agent doesn't need to understand SLSA levels or Sigstore's Rekor log or C2PA manifests. It calls <code>verify_trust_chain()</code> and gets back: trusted or not, why, and the cryptographic evidence.</p>

<pre><code>Agent: verify_trust_chain(
    artifact="npm:some-package@1.2.3",
    trust_root="did:web:mycompany.com"
)

Result: {
    "trusted": true,
    "signer": "did:web:verified-vendor.com",
    "attestations": {
        "slsa_level": 3,
        "provenance": "https://rekor.sigstore.dev/..."
    }
}</code></pre>

<p>The agent gets a deterministic answer. Proceed or don't. No vibes. No heuristics.</p>

<h2>Multi-Provider Architecture</h2>

<p>Different organizations have different signing infrastructure:</p>

<table>
    <thead>
        <tr>
            <th>Provider</th>
            <th>Standards</th>
            <th>Use Case</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><strong>Sigstore</strong></td>
            <td>SLSA, Rekor</td>
            <td>Open source, keyless signing</td>
        </tr>
        <tr>
            <td><strong>C2PA</strong></td>
            <td>Content Credentials</td>
            <td>Media, documents, any artifact</td>
        </tr>
        <tr>
            <td><strong>Enterprise PKI</strong></td>
            <td>X.509, HSM</td>
            <td>Corporate signing infrastructure</td>
        </tr>
        <tr>
            <td><strong>Local</strong></td>
            <td>Ed25519/RSA</td>
            <td>Development, air-gapped</td>
        </tr>
    </tbody>
</table>

<p>The MCP server abstracts the provider. The agent calls <code>verify_signature()</code> — the server routes to the appropriate backend and normalizes the response. When capabilities matter ("I need C2PA manifests for this media file"), the agent can query providers and select appropriately.</p>

<h2>The Trust Graph</h2>

<p>Verification alone isn't enough. The agent also needs to know: <em>who</em> do I trust?</p>

<p>This is where <code>trust.json</code> comes in — a machine-readable declaration of an organization's trust model:</p>

<pre><code>{
  "trust_anchors": [
    "did:web:mycompany.com",
    "did:web:trusted-vendor.com"
  ],
  "verification_policy": {
    "require_signed_attestations": true,
    "min_slsa_level": 2
  }
}</code></pre>

<p>When an agent encounters an artifact, it doesn't just verify the signature is valid — it checks whether the signer is in the trust graph. A perfectly valid signature from an unknown entity still fails verification.</p>

<p>This makes trust decisions deterministic. Given a policy and cryptographic evidence, the answer is yes or no. The agent doesn't have to "decide" — it evaluates.</p>

<h2>Beyond Code</h2>

<p>Here's where it gets interesting: agents don't just consume code. They consume documents, images, API responses, training data, tool definitions. In the age of synthetic everything, <em>any</em> digital artifact can be faked.</p>

<p>C2PA was originally designed for combating deepfakes — embedding cryptographic provenance in media files. But the same approach works for any artifact. A signed PDF. A verified API response. An attested MCP server manifest.</p>

<p>The trust verification primitives we built aren't limited to npm packages. They work for anything with a signature.</p>

<h2>Trust as a Tool, Not a Gate</h2>

<p>Traditional security treats trust as a gate. A human reviews, approves, and the artifact passes through. This works when humans are in the loop.</p>

<p>Agents need trust as a tool. Something they invoke mid-workflow, autonomously, as part of their reasoning. The verification doesn't wait for approval — it happens inline, at machine speed.</p>

<p>This is the shift: from security review to security capability. The agent doesn't ask permission. It has the tools to verify trust itself.</p>

<h2>Getting Started</h2>

<pre><code>pip install code-signing-mcp</code></pre>

<p>Add to Claude Desktop:</p>

<pre><code>{
  "mcpServers": {
    "code-signing": {
      "command": "code-signing-mcp",
      "args": ["--transport", "stdio"]
    }
  }
}</code></pre>

<p>The agent now has access to <code>sign_binary</code>, <code>verify_signature</code>, <code>verify_trust_chain</code>, and <code>supply_chain_attestation</code>.</p>

<h2>The Bigger Picture</h2>

<p>SLSA, Sigstore, in-toto, C2PA — these aren't competing standards. They're complementary layers of a complete digital integrity stack. The industry has been building toward verifiable artifacts for years.</p>

<p>What was missing: agent-accessible interfaces. MCP provides the bridge. Now agents can invoke the same verification capabilities that humans have been using — but autonomously, at scale, as part of their workflow.</p>

<p>Trust decisions shouldn't require human judgment every time. With clear policies and cryptographic evidence, they can be deterministic. That's what we're building toward.</p>

<hr>

<p><strong>Resources:</strong></p>
<ul>
    <li><a href="https://github.com/anthropics/code-signing-mcp">code-signing-mcp on GitHub</a></li>
    <li><a href="https://slsa.dev/">SLSA Framework</a></li>
    <li><a href="https://sigstore.dev/">Sigstore</a></li>
    <li><a href="https://c2pa.org/">C2PA (Content Credentials)</a></li>
    <li><a href="https://noosphere.tech">Noosphere — Digital Integrity Infrastructure</a></li>
</ul>

        </div>
    </article>

    <section class="about-section">
        <div class="container">
            <h3>About DevExp.ai</h3>
            <p>DevExp.ai provides tools and tactics for agent-led growth. We help teams build MCP servers, context graphs, and the infrastructure that makes products discoverable and usable by AI agents.</p>
            <p><a href="/#demo" class="cta-link">Get in Touch →</a></p>
        </div>
    </section>

    <footer class="footer">
        <div class="container">
            <a href="/">Home</a>
            <a href="/blog.html">Blog</a>
            <a href="/.well-known/llms.txt">llms.txt</a>
            <p style="margin-top: 24px;">© 2026 Voyant, LLC</p>
        </div>
    </footer>
</body>
</html>
