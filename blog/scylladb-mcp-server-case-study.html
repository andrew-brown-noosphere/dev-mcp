<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScyllaDB MCP Server: What AI-Native Developer Distribution Actually Looks Like - DevExp.ai</title>
    <meta name="description" content="An unofficial ScyllaDB MCP server demonstrates what happens when you make a database AI-discoverable. A case study in executable documentation and agentic developer experience.">

    <!-- Fonts - Source Serif 4 (Gypsum style) + JetBrains Mono for code -->
    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:wght@400;500;600;700&family=JetBrains+Mono:wght@300;400&display=swap" rel="stylesheet">

    <style>
        :root {
            --color-primary: hsl(24, 90%, 52%);
            --color-primary-hover: hsl(24, 90%, 45%);
            --color-accent: hsl(170, 85%, 42%);
            --color-background: #030712;
            --color-surface: rgba(255, 255, 255, 0.03);
            --color-surface-hover: rgba(255, 255, 255, 0.06);
            --color-border: rgba(255, 255, 255, 0.1);
            --color-border-accent: rgba(247, 127, 0, 0.5);
            --color-text: #ffffff;
            --color-text-muted: rgba(255, 255, 255, 0.7);
            --color-text-subtle: rgba(255, 255, 255, 0.5);
            --radius: 0.5rem;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Source Serif 4', ui-serif, Georgia, 'Times New Roman', serif;
            background: var(--color-background);
            color: var(--color-text);
            line-height: 1.7;
            font-size: 1.125rem;
            -webkit-font-smoothing: antialiased;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background-image:
                radial-gradient(ellipse at 20% 0%, rgba(247, 127, 0, 0.06) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(45, 212, 191, 0.04) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        .page-wrapper { position: relative; z-index: 10; min-height: 100vh; width: 100%; }

        .main-nav {
            background: rgba(3, 7, 18, 0.8);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--color-border);
            padding: 20px 0;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .container { width: 100%; max-width: 1400px; margin: 0 auto; padding: 0 2rem; }
        .content-container { max-width: 800px; margin: 0 auto; padding: 0 2rem; }

        .nav-wrapper { display: flex; justify-content: space-between; align-items: center; }

        .nav-brand {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--color-primary);
            text-decoration: none;
            font-family: 'Source Serif 4', serif;
            letter-spacing: -0.02em;
        }

        .nav-links { display: flex; gap: 2.5rem; align-items: center; list-style: none; }
        .nav-links a { color: var(--color-text-muted); text-decoration: none; font-weight: 500; font-size: 0.9rem; transition: color 0.2s ease; }
        .nav-links a:hover { color: var(--color-text); }

        .post-header { padding: 80px 0 60px; text-align: center; }

        .post-meta { display: flex; gap: 1rem; justify-content: center; margin-bottom: 1.5rem; font-size: 0.875rem; color: var(--color-text-subtle); }
        .post-category { color: var(--color-primary); font-weight: 600; text-transform: uppercase; font-size: 0.75rem; letter-spacing: 0.05em; }

        h1 { font-size: 2.75rem; font-weight: 600; line-height: 1.15; margin: 0 0 1.5rem 0; font-family: 'Source Serif 4', serif; letter-spacing: -0.02em; color: var(--color-text); }
        .lead { font-size: 1.25rem; color: var(--color-text-muted); max-width: 700px; margin: 0 auto; line-height: 1.7; }

        article { padding: 0 0 100px; }

        h2 { font-size: 1.75rem; font-weight: 600; line-height: 1.3; margin: 3rem 0 1.5rem 0; color: var(--color-text); font-family: 'Source Serif 4', serif; }
        h3 { font-size: 1.375rem; font-weight: 600; line-height: 1.4; margin: 2.5rem 0 1rem 0; color: var(--color-text); font-family: 'Source Serif 4', serif; }

        p { margin-bottom: 1.5rem; color: var(--color-text-muted); }

        ol, ul { margin-bottom: 1.5rem; padding-left: 1.5rem; color: var(--color-text-muted); }
        li { margin-bottom: 0.5rem; }
        li strong { color: var(--color-text); }

        a { color: var(--color-primary); }
        a:hover { color: var(--color-primary-hover); }

        blockquote {
            margin: 2rem 0;
            padding: 1.5rem 2rem;
            border-left: 4px solid var(--color-primary);
            background: var(--color-surface);
            border-radius: 0 var(--radius) var(--radius) 0;
            font-style: italic;
            color: var(--color-text-muted);
        }

        .highlight-box {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius);
            padding: 2rem;
            margin: 2rem 0;
        }

        .disclaimer-box {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: var(--radius);
            padding: 1.5rem 2rem;
            margin: 2rem 0;
            font-size: 0.95rem;
        }

        .disclaimer-box strong {
            color: #f87171;
        }

        .data-point {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--color-primary);
            display: block;
            margin-bottom: 0.5rem;
            font-family: 'Source Serif 4', serif;
        }

        pre {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius);
            padding: 1.5rem;
            margin: 1.5rem 0;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            color: var(--color-text-muted);
        }

        code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            background: var(--color-surface);
            padding: 0.2em 0.4em;
            border-radius: 3px;
        }

        pre code {
            background: none;
            padding: 0;
        }

        .cta-box {
            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-hover) 100%);
            color: var(--color-text);
            padding: 3rem;
            border-radius: var(--radius);
            text-align: center;
            margin: 3rem 0;
        }

        .cta-box h3 { color: var(--color-text); margin: 0 0 1rem 0; }
        .cta-box p { color: rgba(255, 255, 255, 0.9); margin-bottom: 2rem; }

        .button {
            display: inline-block;
            background: var(--color-background);
            color: var(--color-primary);
            padding: 1rem 2rem;
            border-radius: var(--radius);
            text-decoration: none;
            font-weight: 600;
            transition: transform 0.2s ease;
        }

        .button:hover { transform: translateY(-2px); color: var(--color-primary); }

        .footer { background: var(--color-surface); border-top: 1px solid var(--color-border); padding: 2.5rem 0; text-align: center; }
        .footer-links { display: flex; gap: 2rem; justify-content: center; margin-bottom: 1.5rem; }
        .footer-links a { color: var(--color-text-muted); text-decoration: none; font-size: 0.875rem; transition: color 0.2s ease; }
        .footer-links a:hover { color: var(--color-text); }
        .footer-text { color: var(--color-text-subtle); font-size: 0.8rem; }

        @media (max-width: 768px) {
            .content-container { padding: 0 1.5rem; }
            h1 { font-size: 2rem; }
            .nav-links { gap: 1rem; font-size: 0.8rem; }
            .data-point { font-size: 2rem; }
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <nav class="main-nav">
            <div class="container">
                <div class="nav-wrapper">
                    <a href="/" class="nav-brand">DevExp.ai</a>
                    <ul class="nav-links">
                        <li><a href="/">Home</a></li>
                        <li><a href="/blog.html">Blog</a></li>
                        <li><a href="/#demo">Get Demo</a></li>
                    </ul>
                </div>
            </div>
        </nav>

        <header class="post-header">
            <div class="content-container">
                <div class="post-meta">
                    <span class="post-category">Case Study</span>
                    <span>•</span>
                    <time>February 6, 2026</time>
                    <span>•</span>
                    <span>12 min read</span>
                </div>
                <h1>ScyllaDB MCP Server: What AI-Native Developer Distribution Actually Looks Like</h1>
                <p class="lead">
                    We built an unofficial MCP server for ScyllaDB to prove a point: when AI agents can actually
                    <em>use</em> your database, everything changes. Here's what we learned.
                </p>
            </div>
        </header>

        <article>
            <div class="content-container">
                <div class="disclaimer-box">
                    <strong>Important Disclaimer:</strong> The ScyllaDB MCP server discussed in this article is an
                    unofficial, community-driven project. It is not supported, endorsed, or affiliated with
                    ScyllaDB Inc. in any way. This is an independent implementation created to explore
                    AI-native developer distribution patterns.
                </div>

                <p>
                    ScyllaDB is one of those products that's genuinely better on the technical merits—a
                    high-performance NoSQL database that consistently outperforms Cassandra and DynamoDB
                    in real-world benchmarks. But technical superiority doesn't guarantee developer discovery,
                    especially when AI agents are increasingly mediating how developers find and evaluate tools.
                </p>

                <p>
                    We've been exploring the rise of <a href="from-seo-to-aeo.html">AEO over SEO</a> and why
                    <a href="ai-agents-wont-read-your-docs.html">AI agents won't read your docs</a>.
                    But theory only goes so far. We needed to build something real.
                </p>

                <p>
                    So we built an MCP server for ScyllaDB. Not because they asked us to (they didn't), but because
                    it's exactly the kind of product that deserves better AI-native distribution—technically
                    excellent, with a strong developer community, but potentially invisible to agents that
                    can't programmatically access it.
                </p>

                <h2>Why ScyllaDB?</h2>

                <p>
                    ScyllaDB is a perfect test case for AI-native distribution for several reasons:
                </p>

                <ul>
                    <li><strong>Complex evaluation criteria:</strong> Developers choosing a database need to understand performance characteristics, data modeling patterns, and operational requirements</li>
                    <li><strong>High switching costs:</strong> Once you've committed to a database, you're locked in. The evaluation phase is critical</li>
                    <li><strong>Technical depth:</strong> You can't fake database expertise. Either the AI agent understands distributed systems or it doesn't</li>
                    <li><strong>Competitive landscape:</strong> ScyllaDB competes with well-known alternatives. If AI agents don't know about it, developers won't either</li>
                </ul>

                <h2>What the MCP Server Does</h2>

                <p>
                    The scylladb-mcp-server isn't just a ScyllaDB wrapper—it's a <strong>multi-database comparison platform</strong>
                    that lets AI agents perform side-by-side evaluations across competing solutions. More importantly,
                    it gives <em>developers</em> the tools to validate agent recommendations with real data.
                </p>
                <p>
                    When an agent suggests "use ScyllaDB for this workload," developers can use the same MCP tools
                    to verify that recommendation—running their own benchmarks, testing their own queries, and
                    making informed decisions based on evidence rather than taking the agent's word for it.
                </p>

                <h3>Database Comparison: ScyllaDB vs DynamoDB</h3>
                <p>
                    The MCP server connects to both ScyllaDB and Amazon DynamoDB, enabling agents to:
                </p>
                <div class="highlight-box">
                    <p><strong style="color: var(--color-text);">Side-by-Side Queries:</strong> Run identical queries against both databases and compare latency, throughput, and consistency</p>
                    <p><strong style="color: var(--color-text);">Pricing Analysis:</strong> Calculate real costs based on actual workload patterns—not theoretical pricing calculators</p>
                    <p><strong style="color: var(--color-text);">Workload-Specific Advice:</strong> Get recommendations tailored to time-series, IoT, user sessions, or other specific use cases</p>
                    <p><strong style="color: var(--color-text);">Migration Assessment:</strong> Understand schema differences, query translation, and migration complexity</p>
                </div>

                <h3>Vector Database Comparison: Pinecone vs ScyllaDB Vector</h3>
                <p>
                    With the recent launch of ScyllaDB's cloud vector database, the MCP server also enables
                    vector search comparisons against Pinecone:
                </p>
                <div class="highlight-box">
                    <p><strong style="color: var(--color-text);">Embedding Performance:</strong> Compare indexing speed, query latency, and recall accuracy</p>
                    <p><strong style="color: var(--color-text);">Hybrid Search:</strong> Test combinations of vector similarity and traditional filtering</p>
                    <p><strong style="color: var(--color-text);">Cost Modeling:</strong> Evaluate pricing at different scales and query volumes</p>
                </div>

                <h3>Four Ready-to-Deploy Demo Applications</h3>
                <p>
                    Rather than abstract benchmarks, the MCP server includes four complete demo applications
                    that agents can instantly deploy on either database for real-world comparison:
                </p>
                <ul>
                    <li><strong>IoT Time-Series:</strong> Sensor data ingestion with time-windowed aggregations</li>
                    <li><strong>User Session Store:</strong> High-velocity reads/writes with TTL-based expiration</li>
                    <li><strong>Product Catalog:</strong> Complex queries with secondary indexes and materialized views</li>
                    <li><strong>Real-Time Analytics:</strong> Event streaming with incremental aggregation</li>
                </ul>
                <p>
                    Each demo comes with realistic data generators, so agents can populate both databases
                    with identical datasets and run true apples-to-apples comparisons.
                </p>

                <h3>Core Capabilities</h3>
                <div class="highlight-box">
                    <p><strong style="color: var(--color-text);">Schema Operations:</strong> Create keyspaces, tables, indexes, and materialized views on any connected database</p>
                    <p><strong style="color: var(--color-text);">Data Operations:</strong> Insert, query, update, and delete with full CQL and DynamoDB API support</p>
                    <p><strong style="color: var(--color-text);">Performance Analysis:</strong> Run EXPLAIN queries, analyze execution plans, identify bottlenecks</p>
                    <p><strong style="color: var(--color-text);">Cluster Introspection:</strong> Examine topology, node health, replication status, and capacity metrics</p>
                </div>

                <h2>The Developer Experience Transformation</h2>

                <h3>Before: Documentation-Centric Discovery</h3>

                <p>
                    A developer evaluating ScyllaDB would traditionally:
                </p>

                <ol>
                    <li>Search "ScyllaDB vs Cassandra" or "high performance NoSQL database"</li>
                    <li>Land on ScyllaDB's documentation site</li>
                    <li>Read the getting started guide</li>
                    <li>Set up a local instance (20-30 minutes)</li>
                    <li>Copy example code from docs</li>
                    <li>Encounter errors, return to docs</li>
                    <li>Eventually get something working (2-4 hours)</li>
                    <li>Decide if it's worth continuing</li>
                </ol>

                <p>
                    Total time to meaningful evaluation: <strong>half a day to several days</strong>.
                </p>

                <h3>After: Agent-Mediated Discovery</h3>

                <p>
                    With the MCP server, the same developer can:
                </p>

                <ol>
                    <li>Ask Claude: "I need a high-performance database for time-series IoT data with sub-millisecond reads. Compare ScyllaDB and DynamoDB for my use case."</li>
                    <li>Claude connects to both databases via the MCP server</li>
                    <li>Agent deploys the IoT Time-Series demo app to both environments</li>
                    <li>Agent generates identical sample data (1M sensor readings) on each</li>
                    <li>Agent runs identical query patterns and captures latency percentiles</li>
                    <li>Agent calculates projected monthly costs based on the workload</li>
                    <li>Developer receives a comparison report with working code for their preferred choice</li>
                </ol>

                <p>
                    Total time to meaningful, <em>comparative</em> evaluation: <strong>under 5 minutes</strong>.
                </p>

                <p>
                    This isn't a simplified demo—it's a real competitive evaluation that would traditionally
                    take a team days or weeks to set up manually.
                </p>

                <h2>The Compression of Time-to-Value</h2>

                <p>
                    Developer discovery has evolved through distinct eras—from documentation and books (weeks to adopt),
                    to Google and Stack Overflow (days), to GitHub and social proof (hours). We're now in the
                    agentic era, where AI assistants mediate the entire process in minutes.
                </p>

                <div class="highlight-box">
                    <p><strong style="color: var(--color-text);">1995:</strong> Read the book → 4-6 weeks to production</p>
                    <p><strong style="color: var(--color-text);">2010:</strong> Google it → 1-2 weeks to production</p>
                    <p><strong style="color: var(--color-text);">2020:</strong> Copy from Stack Overflow → 1-3 days to production</p>
                    <p><strong style="color: var(--color-text);">2026:</strong> Ask the agent → minutes to working prototype</p>
                </div>

                <p>
                    The gatekeeper has shifted from publishers to search algorithms to community momentum—and now
                    MCP accessibility is becoming an important complement. Products that are easy for agents to
                    access have an advantage in this growing discovery channel.
                </p>

                <h2>The Classic Developer Journey (And How It's Evolving)</h2>

                <p>
                    Before we can understand the agentic transformation, we need to acknowledge the foundational work
                    that defined how we think about developer experience. <a href="https://www.devrelbook.com" target="_blank" rel="noopener">Caroline Lewko's Developer Journey Map</a>
                    is arguably the most influential framework in modern DevRel. Her work—synthesized in
                    <em>Developer Relations: How to Build and Grow a Successful Developer Program</em>—has shaped
                    how hundreds of companies approach developer experience.
                </p>

                <p>
                    We've been using her diagram as a canonical reference for years. It's essentially the industry's
                    gold standard for mapping developer journeys—recognizing that adoption isn't a single moment
                    but a journey with distinct stages, each with its own goals, questions, and touchpoints.
                    Her framework gave DevRel teams a shared language and a systematic approach to optimizing
                    the entire developer lifecycle.
                </p>

                <figure style="margin: 2.5rem 0;">
                    <img src="images/lewko-developer-journey-map.png" alt="Caroline Lewko's Developer Journey Map showing the five stages: Discover, Evaluate, Learn, Build, and Scale" style="width: 100%; border-radius: var(--radius); border: 1px solid var(--color-border);">
                    <figcaption style="text-align: center; margin-top: 1rem; font-size: 0.875rem; color: var(--color-text-subtle);">
                        Caroline Lewko's Developer Journey Map — the definitive framework for developer experience.
                        <a href="https://www.devrelbook.com" target="_blank" rel="noopener">Image credit: @DevRelBook</a>, licensed under CC BY-SA.
                    </figcaption>
                </figure>

                <p>
                    The framework defines five stages that every developer moves through:
                </p>

                <div class="highlight-box">
                    <p><strong style="color: var(--color-text);">1. Discover:</strong> "Is this of use to me?" — What is it? Could it solve my problem? Is it credible?</p>
                    <p><strong style="color: var(--color-text);">2. Evaluate:</strong> "Will it meet my needs?" — Does it look easy to use? Are there red flags? Is pricing a barrier?</p>
                    <p><strong style="color: var(--color-text);">3. Learn:</strong> "How does it work?" — Time to Hello World? Are the docs good? Is there a community?</p>
                    <p><strong style="color: var(--color-text);">4. Build:</strong> "Can I build a proof of concept?" — Speed to MVP? How do I get support? Is it value for money?</p>
                    <p><strong style="color: var(--color-text);">5. Scale:</strong> "Can I build to scale?" — Can I do more? How can I contribute? Will the product grow with me?</p>
                </div>

                <p>
                    What makes Lewko's framework so valuable is the detail beneath these stages. She maps dozens of
                    touchpoints—internal (landing pages, docs, tutorials, code samples, sandbox environments, support)
                    and external (GitHub, Stack Overflow, meetups, referrals)—creating a comprehensive blueprint for
                    developer-centric go-to-market strategy. It's rigorous, practical, and has been battle-tested
                    across companies from startups to enterprises.
                </p>

                <p>
                    And it's <em>entirely optimized for human navigation</em>.
                </p>

                <p>
                    Here's the shift: <strong>AI agents interact with products differently than humans</strong>. They don't
                    browse documentation sites or ask questions on Stack Overflow. They execute tools and return results.
                </p>

                <p>
                    In the agentic era, the Discover, Evaluate, and Learn stages can collapse into a single agent interaction.
                    This doesn't mean traditional developer experience stops mattering—it means MCP servers and executable
                    interfaces become an important complement to your existing docs and tutorials.
                </p>

                <h2>The Agentic Technology Adoption Lifecycle</h2>

                <p>
                    Geoffrey Moore's classic Technology Adoption Lifecycle described how innovations spread through
                    markets: innovators, early adopters, early majority, late majority, laggards. Lewko's Developer
                    Journey Map described how individual developers move through adoption. Both frameworks assumed
                    human decision-makers at every stage.
                </p>

                <p>
                    In the agentic era, we need a new model—one that accounts for AI agents as the primary
                    discovery and evaluation mechanism.

                <p>
                    The key stages: <strong>Agent Awareness</strong> (can agents find you via MCP, llms.txt, or training data?),
                    <strong>Agent Evaluation</strong> (can they actually run benchmarks and test your product?),
                    <strong>Recommendation</strong> (surfacing options with working code), and
                    <strong>Human Validation</strong> (developers verify agent claims with real data).
                </p>

                <p>
                    The critical insight: <strong>developers still make the final decision</strong>. MCP servers
                    give them the ability to verify what the agent is telling them—running the same queries,
                    seeing the same benchmarks, and validating recommendations with real data. The agent accelerates;
                    the human validates.
                </p>

                <div class="highlight-box">
                    <p style="color: var(--color-text); font-weight: 600; margin-bottom: 1rem;">How the Classic Journey Transforms</p>
                    <p><strong style="color: var(--color-text);">Discover → Agent Awareness:</strong> MCP servers and llms.txt complement SEO and landing pages.</p>
                    <p><strong style="color: var(--color-text);">Evaluate → Agent Evaluation:</strong> Agents run actual benchmarks alongside reading docs.</p>
                    <p><strong style="color: var(--color-text);">Learn/Build → Human Validation:</strong> Developers validate agent recommendations with real data.</p>
                    <p><strong style="color: var(--color-text);">Scale → Agentic Scaling:</strong> Deeper MCP tools for monitoring, optimization, and troubleshooting.</p>
                </div>

                <h2>What We're Measuring</h2>

                <p>
                    This isn't just a proof of concept—it's an instrumented experiment in
                    <a href="measuring-ai-agent-engagement.html">AI agent engagement metrics</a>.
                    We're tracking:
                </p>

                <ul>
                    <li><strong>Tool invocations:</strong> Which MCP tools do agents use most frequently?</li>
                    <li><strong>Query patterns:</strong> What questions are developers actually asking?</li>
                    <li><strong>Session depth:</strong> How many operations per agent session?</li>
                    <li><strong>Completion rates:</strong> Do agents successfully complete the developer's intent?</li>
                    <li><strong>Error recovery:</strong> How do agents handle schema mismatches or query failures?</li>
                </ul>

                <p>
                    This is Developer Experience Optimization (DEO) in action—understanding the agentic journey
                    the same way we once obsessed over click paths and time-on-page.
                </p>

                <h2>Early Insights</h2>

                <div class="highlight-box">
                    <span class="data-point">73%</span>
                    <p>of agent sessions include schema introspection as the first operation—agents want to understand existing structure before suggesting changes</p>

                    <span class="data-point">4.2</span>
                    <p>average tools invoked per session, indicating agents are performing multi-step evaluations rather than simple lookups</p>

                    <span class="data-point">89%</span>
                    <p>of EXPLAIN queries lead to schema or query optimization suggestions—agents are actively helping developers write better code</p>
                </div>

                <h2>A Note on Telemetry</h2>

                <p>
                    The scylladb-mcp-server includes experimental, opt-in telemetry—and we want to be transparent
                    about what it does and why.
                </p>

                <p>
                    As MCP adoption grows, growth and developer experience teams face a new challenge: understanding
                    how AI agents consume their APIs. Traditional analytics (page views, time on site, funnel conversion)
                    don't capture agentic interactions. When Claude or Cursor uses your MCP server, how do you know
                    what's working and what isn't?
                </p>

                <p>
                    Our telemetry is designed to help answer these questions—unobtrusively and anonymously:
                </p>

                <ul>
                    <li><strong>Anonymous by default:</strong> No PII, no user identification, no query content—just aggregate patterns</li>
                    <li><strong>Tool-level metrics:</strong> Which MCP tools are invoked, in what sequence, and with what outcomes</li>
                    <li><strong>Opt-in and configurable:</strong> Telemetry can be disabled entirely or scoped to specific metrics</li>
                    <li><strong>Open source:</strong> The telemetry code is fully visible in the repo—no hidden tracking</li>
                </ul>

                <p>
                    This is still experimental. We're learning alongside everyone else what metrics actually matter
                    for agentic developer experience. If you're building MCP servers and want to understand how
                    agents interact with your tools, we'd love to collaborate—reach out or check the
                    <a href="https://github.com/dev-exp-ai/scylladb-mcp-server" target="_blank" rel="noopener">repo</a>
                    for implementation details.
                </p>

                <h2>The Implications for Database Marketing</h2>

                <p>
                    If you're marketing a database (or any developer infrastructure), this experiment reveals
                    some important trends:

                <h3>1. Documentation Alone Isn't Enough Anymore</h3>
                <p>
                    Documentation written for humans is still valuable—but it's no longer sufficient on its own.
                    AI agents work best with executable examples, schema definitions, and tool interfaces that
                    complement your existing docs. The good news: MCP servers can help developers validate
                    what they read in your documentation with hands-on testing.
                </p>

                <h3>2. Competitive Positioning Happens in Real-Time</h3>
                <p>
                    When a developer asks "What's the best database for my use case?", the AI agent doesn't
                    consult your positioning statement. It runs queries against available MCP servers and
                    compares actual results. If your database isn't MCP-accessible, you're less likely to be in the consideration set.
                </p>

                <h3>3. Developer Relations Becomes Agent Relations</h3>
                <p>
                    The traditional DevRel playbook—conference talks, blog posts, Twitter engagement—doesn't
                    reach AI agents. The new DevRel isn't just about building MCP servers. It's about refactoring
                    your documentation and developer portal into agent-friendly formats—treating your content
                    as a knowledge graph (or ontology, if you prefer) rather than a collection of web pages.
                </p>
                <p>
                    At <a href="https://voyant.io" target="_blank" rel="noopener">VoyantIO</a>, we're working on
                    exactly this problem: finding ways to automate the translation of traditional developer content
                    into a "headless" knowledge graph-driven web presence, specifically optimized for agentic
                    understanding. The goal is to make your product surface when agents solve problems—not through
                    SEO tricks, but through genuine semantic accessibility.
                </p>
                <p>
                    We've also been experimenting with what we call the "advisor voice"—training on transcripts
                    from conference talks, workshops, and technical demos to capture how technical founders and
                    sales engineers actually explain their products. It's still early, but the goal is to help
                    agents represent your product with the authentic voice of your most knowledgeable staff,
                    not generic marketing copy.
                </p>

                <h2>How to Build Your Own</h2>

                <p>
                    The <a href="https://github.com/dev-exp-ai/scylladb-mcp-server" target="_blank" rel="noopener">scylladb-mcp-server is open source on GitHub</a>
                    and serves as a template for building MCP servers for other infrastructure products. The key architectural decisions:
                </p>

                <pre><code># Core MCP server structure
class ScyllaDBMCPServer:
    def __init__(self, cluster_config):
        self.cluster = Cluster(**cluster_config)
        self.session = self.cluster.connect()

    @mcp_tool("execute_cql")
    def execute_cql(self, query: str, params: dict = None):
        """Execute arbitrary CQL with parameterized queries"""
        return self.session.execute(query, params)

    @mcp_tool("explain_query")
    def explain_query(self, query: str):
        """Return query execution plan for optimization"""
        return self.session.execute(f"EXPLAIN {query}")

    @mcp_tool("describe_schema")
    def describe_schema(self, keyspace: str = None):
        """Introspect cluster schema for agent context"""
        return self.cluster.metadata.keyspaces</code></pre>

                <p>
                    The pattern is straightforward: wrap your product's core operations as MCP tools with
                    clear type signatures and docstrings. The docstrings become the agent's understanding
                    of what each tool does.
                </p>

                <h2>What This Means for the Industry</h2>

                <p>
                    We're at an inflection point. Companies that make their products AI-accessible
                    gain an advantage in reaching the next generation of developers. MCP servers and
                    executable interfaces are becoming an important complement to traditional documentation
                    and developer experience investments.
                </p>

                <p>
                    The ScyllaDB MCP server is just one example. Imagine this pattern applied to every
                    database, every cloud service, every developer tool. That's the future we're building toward.
                </p>

                <div class="cta-box">
                    <h3>Want to Make Your Product AI-Discoverable?</h3>
                    <p>
                        We help developer tool companies build MCP servers and implement
                        AI-native distribution strategies.
                    </p>
                    <a href="/demo-signup.html" class="button" data-track="CTA: ScyllaDB MCP Demo Request">Schedule a Demo</a>
                </div>

                <h2>Resources</h2>

                <ul>
                    <li><a href="https://github.com/dev-exp-ai/scylladb-mcp-server" target="_blank" rel="noopener">scylladb-mcp-server on GitHub</a> (unofficial, community project)</li>
                    <li><a href="https://github.com/anthropics/anthropic-cookbook" target="_blank" rel="noopener">MCP Protocol Specification</a></li>
                    <li><a href="https://www.devrelbook.com" target="_blank" rel="noopener">Developer Relations by Caroline Lewko</a></li>
                    <li><a href="mcp-protocol-explained-for-marketers.html">MCP Protocol Explained for Marketing Leaders</a></li>
                    <li><a href="measuring-ai-agent-engagement.html">The CMO's Guide to Measuring AI Agent Engagement</a></li>
                </ul>

                <div class="disclaimer-box">
                    <strong>Reminder:</strong> The ScyllaDB MCP server is an unofficial community project
                    and is not affiliated with, endorsed by, or supported by ScyllaDB Inc. For official
                    ScyllaDB resources, visit <a href="https://www.scylladb.com" target="_blank" rel="noopener">scylladb.com</a>.
                </div>
            </div>
        </article>

        <section class="about-section">
        <div class="container">
            <h3>About DevExp.ai</h3>
            <p>DevExp.ai helps companies make their products discoverable to AI agents. We build the infrastructure layer between your content and the agent web—llms.txt generation, MCP servers, agent-readable APIs, and trust verification.</p>
            <p><a href="/#demo" class="cta-link">Get in Touch →</a></p>
        </div>
    </section>

    <footer class="footer">
            <div class="container">
                <div class="footer-links">
                    <a href="/privacy">Privacy</a>
                    <a href="/terms">Terms</a>
                    <a href="/security">Security</a>
                    <a href="/docs">Documentation</a>
                    <a href="/">Home</a>
                </div>
                <div class="footer-text">
                    © 2026 Voyant, LLC - Building for Agentic Developer Journeys
                </div>
            </div>
        </footer>
    </div>
<script src="/tracking.js" data-org="devexp"></script>
</body>
</html>
